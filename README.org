#+title: Datumbazo
#+author: r0man
#+LANGUAGE: en

[[https://travis-ci.org/r0man/datumbazo][https://travis-ci.org/r0man/datumbazo.svg]]
[[http://jarkeeper.com/r0man/datumbazo][http://jarkeeper.com/r0man/datumbazo/status.svg]]
[[http://jarkeeper.com/r0man/datumbazo][http://jarkeeper.com/r0man/datumbazo/downloads.svg]]

Database Kung Fu in Clojure.

[[http://imgs.xkcd.com/comics/exploits_of_a_mom.png]]

* Installation

  [[https://clojars.org/datumbazo][https://clojars.org/datumbazo/latest-version.svg]]

* Usage
** Imports

   The =datumbazo.core= namespace shadows some Clojure core
   functions. If you want to use or refer to all symbols from that
   namespace you need to exclude them.

   #+BEGIN_SRC clojure :exports code :results silent
  (refer-clojure :exclude '[distinct group-by update])
  (require '[datumbazo.core :refer :all])
   #+END_SRC

** Database component

   You can make a new database [[https://github.com/stuartsierra/component][component]] from an URL with the =new-db=
   function..

   #+BEGIN_SRC clojure :exports both :results silent
     (def db-spec (new-db "postgresql://tiger:scotch@localhost/datumbazo"))
   #+END_SRC

   A database component can be started and stopped with the =start=
   and =stop= functions from the [[https://github.com/stuartsierra/component][component]] library. This opens a
   connection to the database and binds the updated component to the
   =db= symbol.

   #+BEGIN_SRC clojure :exports both :results silent
     (require '[com.stuartsierra.component :as component])
     (def db (component/start db-spec))
   #+END_SRC

** Select

   Select a simple expression. Note that the column names in the
   result are generated by the database driver and are database vendor
   specific.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db [1 2 3])
   #+END_SRC

   #+RESULTS:
   : ({:?column? 1, :?column?_2 2, :?column?_3 3})

   Select the result of a function call.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db ['(- (now) (cast "1 day" :interval))])
   #+END_SRC

   #+RESULTS:
   : ({:?column? #inst "2016-02-16T20:41:17.040-00:00"})

   Select columns from the =information_schema.tables= table.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db [:table_catalog :table_schema :table_name]
        (from :information_schema.tables)
        (where '(= :table_name "pg_statistic")))
   #+END_SRC

   #+RESULTS:
   : ({:table_catalog "datumbazo", :table_schema "pg_catalog", :table_name "pg_statistic"})

** Create table

   Create a countries table with =name= and =code= columns.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(create-table db :countries
        (column :id :serial :primary-key? true)
        (column :name :text)
        (column :code :text))
   #+END_SRC

   #+RESULTS:
   : [{:count 0}]

** Insert

   Insert a row into the countries table and return the inserted rows.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(insert db :countries []
        (values [{:code "de" :name "Germany"}
                 {:code "es" :name "Spain"}])
        (returning :*))
   #+END_SRC

   #+RESULTS:
   : ({:id 1, :name "Germany", :code "de"} {:id 2, :name "Spain", :code "es"})

** Order by

   Select all countries ordered by the =name= column in ascending
   order.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db [:*]
        (from :countries)
        (order-by (asc :name)))
   #+END_SRC

   #+RESULTS:
   : ({:id 1, :name "Germany", :code "de"} {:id 2, :name "Spain", :code "es"})

** Where clauses

   Select the =id= and =code= columns of the =countries= table for all
   rows whose =name= columns is equal to =Spain=.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db [:id :code]
        (from :countries)
        (where '(= :name "Spain")))
   #+END_SRC

   #+RESULTS:
   : ({:id 2, :code "es"})

** Delete

   Delete a country by name, and return the affected rows.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(delete db :countries
        (where '(= :name "Spain"))
        (returning :*))
   #+END_SRC

   #+RESULTS:
   : ({:id 2, :name "Spain", :code "es"})

** Drop table

   Drop the countries table.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(drop-table db [:countries])
   #+END_SRC

   #+RESULTS:
   : [{:count 0}]

* License

  Copyright Â© 2012-2015 roman

  Distributed under the Eclipse Public License, the same as Clojure.
