#+title: Datumbazo
#+author: r0man
#+LANGUAGE: en

[[https://travis-ci.org/r0man/sqlingvo][https://travis-ci.org/r0man/datumbazo.png]]
[[http://jarkeeper.com/r0man/sqlingvo][http://jarkeeper.com/r0man/datumbazo/status.png]]

Database Kung Fu in Clojure.

[[http://imgs.xkcd.com/comics/exploits_of_a_mom.png]]

* Installation

  [[https://clojars.org/sqlingvo][https://clojars.org/datumbazo/latest-version.svg]]

* Usage
** Imports

   Datumbazo shadows some Clojure core functions, so exclude them.

   #+BEGIN_SRC clojure :exports code :results silent
  (refer-clojure :exclude '[distinct group-by])
  (require '[datumbazo.core :refer :all])
   #+END_SRC

** Database connection

   Define a database connection.

   #+BEGIN_SRC clojure :exports both :results silent
    (def db (new-db "postgresql://tiger:scotch@localhost/datumbazo"))
   #+END_SRC

** Select

   Select expressions. Note that the column names are generated by the
   database driver and are database vendor specific.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(select db [1 2 3])
   #+END_SRC

   #+RESULTS:
  : ({:?column?-3 3, :?column?-2 2, :?column? 1})

   Call functions in an expression.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(select db ['(- (now) (cast "1 day" :interval))])
   #+END_SRC

   #+RESULTS:
  : ({:?column? #inst "2014-11-30T00:30:56.014-00:00"})

   Query the information schema.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(select db [:table-catalog :table-schema :table-name]
       (from :information-schema.tables)
       (where '(= :table-name "pg_statistic")))
   #+END_SRC

   #+RESULTS:
  : ({:table-name "pg_statistic", :table-schema "pg_catalog", :table-catalog "datumbazo"})

** Create table

   Create a countries table with `name` and `code` columns.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(create-table db :countries
       (column :id :serial :primary-key? true)
       (column :name :text)
       (column :code :text))
   #+END_SRC

   #+RESULTS:
   : ({:count 0})

** Insert

   Insert a row into the countries table and return the inserted rows.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(insert db :countries []
       (values [{:code "de" :name "Germany"}
                {:code "es" :name "Spain"}])
       (returning :*))
   #+END_SRC

   #+RESULTS:
   : ({:code "de", :name "Germany", :id 1} {:code "es", :name "Spain", :id 2})

** Order by

   Select all countries ordered by name, in ascending order.

   #+BEGIN_SRC clojure :exports both :results verbatim
     @(select db [:*]
        (from :countries)
        (order-by (asc :name)))
   #+END_SRC

   #+RESULTS:
   : ({:code "de", :name "Germany", :id 1} {:code "es", :name "Spain", :id 2})

** Where clauses

   Select the country id and code by name.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(select db [:id :code]
       (from :countries)
       (where '(= :name "Spain")))
   #+END_SRC

   #+RESULTS:
  : ({:code "es", :id 2})

** Delete

   Delete a country by name, and return the affected rows.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(delete db :countries
       (where '(= :name "Spain"))
       (returning :*))
   #+END_SRC

   #+RESULTS:
  : ({:code "es", :name "Spain", :id 2})

** Drop table

   Drop the countries table.

   #+BEGIN_SRC clojure :exports both :results verbatim
    @(drop-table db [:countries])
   #+END_SRC

   #+RESULTS:
   : ({:count 0})

* License

  Copyright Â© 2012-2015 roman

  Distributed under the Eclipse Public License, the same as Clojure.
