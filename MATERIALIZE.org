* Explore Materialize’s API

  Start Materialize.io with Docker.

  #+BEGIN_SRC sh
    docker run -p 6875:6875 materialize/materialized:v0.6.0 --workers 1
  #+END_SRC

  Import the datumbazo library.

  #+BEGIN_SRC clojure :exports code :results silent
    (require '[datumbazo.core :as sql])
  #+END_SRC

  Define how to connect to the database.

  #+BEGIN_SRC clojure :exports code :results silent
    (def db (sql/db "postgresql://localhost:6875/materialize"))
  #+END_SRC

  Materialize offers ANSI Standard SQL, but is not simply a relational
  database. Instead of tables of data, you typically connect
  Materialize to external sources of data (called sources), and then
  create materialized views of the data that Materialize sees from
  those sources.

  To get started, though, we’ll begin with a simple version that
  doesn’t require connecting to an external data source.

  From your Materialize CLI, create a materialized view that contains
  actual data we can work with.

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/create-materialized-view db :pseudo-source [:key :value]
       (sql/values [["a" 1] ["a" 2] ["a" 3] ["a" 4] ["b" 5] ["c" 6] ["c" 7]]))
  #+END_SRC

  #+RESULTS:
  : [{:count 0}]

  You’ll notice that we end up entering data into Materialize by
  creating a materialized view from some other data, rather than the
  typical INSERT operation. This is how one interacts with
  Materialize. In most cases, this data would have come from an
  external source and get fed into Materialize from a file or a
  stream.

  With data in a materialized view, we can perform arbitrary SELECT
  statements on the data.

  Let’s start by viewing all of the data:

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/select db [:*]
       (sql/from :pseudo-source))
  #+END_SRC

  #+RESULTS:
  : ({:key "a", :value 1} {:key "a", :value 2} {:key "a", :value 3} {:key "a", :value 4} {:key "b", :value 5} {:key "c", :value 6} {:key "c", :value 7})

  Determine the sum of the values for each key:

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/select db [:key '(sum :value)]
       (sql/from :pseudo-source)
       (sql/group-by :key))
  #+END_SRC

  #+RESULTS:
  : ({:key "a", :sum 10} {:key "b", :sum 5} {:key "c", :sum 13})

  We can actually then save this query as its own materialized view:

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/create-materialized-view db :key-sums []
       (sql/select db [:key '(sum :value)]
         (sql/from :pseudo-source)
         (sql/group-by :key)))
  #+END_SRC

  #+RESULTS:
  : [{:count 0}]

  Determine the sum of all keys’ sums:

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/select db ['(sum :sum)]
       (sql/from :key-sums))
  #+END_SRC

  #+RESULTS:
  : ({:sum 28})

  We can also perform complex operations like JOINs. Given the
  simplicity of our data, the JOIN clauses themselves aren’t very
  exciting, but Materialize offers support for a full range of
  arbitrarily complex JOINs.

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/create-materialized-view db :lhs [:key :value]
       (sql/values [["x" "a"] ["y" "b"] ["z" "c"]]))
  #+END_SRC

  #+RESULTS:
  : [{:count 0}]

  #+BEGIN_SRC clojure :exports both :results verbatim
    @(sql/select db [:lhs.key '(sum :rhs.value)]
       (sql/from :lhs)
       (sql/join (sql/as :pseudo-source :rhs) '(on (= :lhs.value :rhs.key)))
       (sql/group-by :lhs.key))
  #+END_SRC

  #+RESULTS:
  : ({:key "x", :sum 10} {:key "y", :sum 5} {:key "z", :sum 13})

  Of course, these are trivial examples, but hope begin to illustrate
  some of Materialize’s potential.
